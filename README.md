# HOTPOT.AI - AI-Powered Cooking Game

**Overview:** This document outlines a comprehensive plan for developing a web-based cooking game that uses a Large Language Model (LLM) as a core creative agent. The game is inspired by **Infinite Craft** (an endless AI-driven crafting game) and popular cooking games like *The Legend of Zelda: Breath of the Wild*, *Genshin Impact*, *Overcooked*, and *Cooking Mama*. Players will be able to combine ingredients and cooking methods in creative ways to produce new dishes, with an LLM generating unique outcomes. The guidelines are organized into four phases, each addressing key design and development aspects.

## 1. Foundational Research & Conceptual Design

### Comparative Analysis of Inspiration Games  
Before designing our game, we examine key features of Infinite Craft and other cooking games to learn from their strengths:

| **Game**            | **Key Cooking Mechanics and Features** |
| ------------------- | -------------------------------------- |
| **Infinite Craft** (2024) | An *“endless crafting”* browser game that uses an LLM (Llama 2) to generate results for any new combination of elements ([How does the game infinite craft work? : r/NoStupidQuestions](https://www.reddit.com/r/NoStupidQuestions/comments/1atymj3/how_does_the_game_infinite_craft_work/#:~:text=%3E%20,what%20the%20result%20should%20be)). Unlike fixed-recipe games, it emphasizes open-ended discovery – *“it uses generative AI to introduce reactivity and experimentation in its responses, rather than a puzzle-solving ethos with set combinations”* ([This browser-based 'endless crafting game' starts you off with fire and water, but it quickly escalates to God, the Big Bang, and 'Yin-Yoda' | PC Gamer](https://www.pcgamer.com/this-browser-based-endless-crafting-game-starts-you-off-with-fire-and-water-but-it-quickly-escalates-to-god-the-big-bang-and-yin-yoda/#:~:text=The%20difference%20in%20Infinite%20Craft,Agarwal%20informed%20me)). Players start with basic elements and can craft anything their imagination (and the AI) allows. |
| **Breath of the Wild** (2017) | Open-world action RPG with a cooking system focused on experimentation. Players can combine up to five ingredients in a cooking pot to discover meals. The design *“encouraged a trial-and-error attitude to whipping up meals, learning from the outcomes of unusual concoctions and experimenting again”* ([Zelda: Breath of the Wild cooking explained - ingredients list, bonus effects, and how to cook with the cooking pot | Eurogamer.net](https://www.eurogamer.net/zelda-breath-of-the-wild-cooking-ingredients-list-bonus-effects-how-to-cook-with-the-cooking-pot-4857#:~:text=Cooking%20in%20Breath%20of%20the,mean%20there%20isn%27t%20a%20clear)). Ingredient combinations always yield a result (even if it's a low-quality “Dubious Food”), rewarding creativity and exploration. |
| **Genshin Impact** (2020) | RPG with a recipe-based cooking mechanic. Players unlock recipes and gather ingredients to cook predefined dishes via a timing mini-game. Each dish can have 3 quality tiers – *Suspicious*, normal, or *Delicious* – which alter its effectiveness ([Food | Genshin Impact Wiki | Fandom](https://genshin-impact.fandom.com/wiki/Food#:~:text=Food%20items%20have%203%20different,regardless%20of%20the%20food%27s%20quality)). Perfect timing yields “Delicious” meals (best stats) while mistakes produce “Suspicious” versions (weaker effects). Cooking is deterministic (following recipes), focusing on execution rather than discovery. |
| **Overcooked** (2016) | A cooperative cooking party game emphasizing teamwork and time management. Players work together in chaotic kitchen levels to prepare and serve orders under time pressure. The design is built around communication and coordination – *“a game which was much more focused on how a team works together rather than simply adding more players to a single player experience”* ([Game Design Deep Dive: Building truly cooperative play in Overcooked](https://www.gamedeveloper.com/design/game-design-deep-dive-building-truly-cooperative-play-in-i-overcooked-i-#:~:text=team%20works%20together%20rather%20than,to%20a%20single%20player%20experience)). There is no recipe discovery (orders are given to the players), highlighting strategy and quick execution over creativity. |
| **Cooking Mama** (2006) | A single-player cooking simulation where players progress through recipes by completing short touch-screen mini-games. The player uses gestures (stylus swipes, etc.) *“to chop vegetables, slice meat, flip food in pans, and arrange the final dish”*, each action represented as a quick mini-game ([Cooking Mama | Cooking Mama Wiki | Fandom](https://cookingmama.fandom.com/wiki/Cooking_Mama#:~:text=the%20player%20uses%20the%20stylus,to%20Cooking%20Mama%3A%20Cook%20Off)). There are a fixed number of recipes, and success is measured by accuracy and speed (scored by Mama with bronze/silver/gold awards). It emphasizes skill in following steps rather than inventing new dishes, though some versions include a “Let’s Combine” mode to mix recipes for novelty.

**Takeaways:** Our game will borrow the open-ended **creativity** of Infinite Craft and BOTW, letting players experiment freely, while incorporating a **quality tier** concept similar to Genshin for outcome grading. Unlike Overcooked or Cooking Mama, our focus is not on action or mini-game skill, but on **creative combination and exploration**. However, elements of **progression** and **feedback** from those games (like Cooking Mama’s scoring or Overcooked’s teamwork aspects) can inspire how we provide goals and social elements.

 ([Cooking - Zelda Wiki](https://zelda.fandom.com/wiki/Cooking)) *Breath of the Wild’s cooking system encourages mixing ingredients to discover recipes ([Zelda: Breath of the Wild cooking explained - ingredients list, bonus effects, and how to cook with the cooking pot | Eurogamer.net](https://www.eurogamer.net/zelda-breath-of-the-wild-cooking-ingredients-list-bonus-effects-how-to-cook-with-the-cooking-pot-4857#:~:text=Cooking%20in%20Breath%20of%20the,mean%20there%20isn%27t%20a%20clear)). Our game will similarly reward experimentation, but with an LLM ensuring *every* combination produces some result.*  

### Core Game Loop Definition  
Designing a clear **core loop** is crucial. The envisioned core gameplay loop for our cooking game is: 

1. **Gather Ingredients:** The player acquires ingredients (foraging, farming, or purchasing from a market). New ingredients unlock more combination possibilities.  
2. **Choose Cooking Method:** The player selects a cooking method (e.g. baking, boiling, frying, mixing). Different methods combined with the same ingredients could yield different results – introducing another dimension for the LLM to consider.  
3. **Combine & Cook (LLM Generation):** The player combines ingredients + method and initiates cooking. The LLM agent then generates the outcome: a dish name, description, and base quality. This is the creative payoff – much like Infinite Craft always returns *something* for any combo ([How does the game infinite craft work? : r/NoStupidQuestions](https://www.reddit.com/r/NoStupidQuestions/comments/1atymj3/how_does_the_game_infinite_craft_work/#:~:text=%3E%20,what%20the%20result%20should%20be)). Even absurd ingredient combinations will produce an item, leading to surprises and humor.  
4. **Receive Dish & Feedback:** The new dish is added to the player’s inventory. The game provides feedback on its quality/taste (e.g. a 1-5 star rating or tier like “Suspicious” vs “Delicious”). The player can view a description (flavor text) generated by the LLM, adding lore or fun context to the item.  
5. **Utilize or Trade Outcome:** The dish can be used or sold. For example, the player might **consume** it for buffs (in a fantasy RPG context), **sell** it in their shop for in-game currency, or **deliver** it to an NPC/customer to complete a quest or order. This leads to resource gain or story progress, feeding back into step 1 (buy more ingredients, unlock new requests, etc.).  

This loop ensures continual experimentation (to discover new recipes) and progression (through earning money or fulfilling requests). It’s important that the loop is **fun even in failure** – thanks to the LLM, even a “bad” recipe produces a funny or unexpected result instead of a dead-end.

### LLM Agent Design & Integration Strategy  
At the heart of the game is the **LLM-powered cooking agent**. This agent will act as the “creative chef brain” of the game:

- **Role of the LLM:** Generate a *plausible and extremely accurate* dish result for any given combination of ingredients and cooking method. The final dish could end up a "failure" and be unedible. This will teach users the rules of cooking. Essentially, the LLM will answer: *“What do we get if we cook X, Y, and Z with method M?”*. For example, combining “flour, baking powder, sugar, and salt" and "mixing for 30 seconds" might yield a "Basic Pancake Mix” with a quirky description. Then, adding "Basic Pancake Mix" with "2% fat milk, melted butter, and eggs" with "mix" and a modifier "until smooth" would make "Old-Fashioned Pancake Batter". The LLM’s ability to draw on a vast culinary (and inventive) knowledge base will allow for an *infinite variety of dishes*. This mirrors Infinite Craft’s approach of querying an LLM for every new combination ([How does the game infinite craft work? : r/NoStupidQuestions](https://www.reddit.com/r/NoStupidQuestions/comments/1atymj3/how_does_the_game_infinite_craft_work/#:~:text=%3E%20,what%20the%20result%20should%20be)), ensuring no combination is invalid.  
- **Integration Approach:** The LLM will be accessed via an API call on the backend. Each time the player cooks a new combination, the backend sends a prompt to the LLM. For consistency and to reduce cost, the system will cache results: if the same combination is attempted again, the previously generated dish is reused (and perhaps the game informs the player it’s already known, akin to Infinite Craft’s “First Discovery” note ([How does the game infinite craft work? : r/NoStupidQuestions](https://www.reddit.com/r/NoStupidQuestions/comments/1atymj3/how_does_the_game_infinite_craft_work/#:~:text=Presumably%2C%20combinations%20that%20have%20already,up%20without%20asking%20the%20LLM))). Caching prevents asking the LLM repeatedly for the same inputs.  
- **Prompt Design (Initial):** The prompt should be crafted to guide the LLM to output a concise dish name and an appetizing description (and perhaps a hint of quality). For example: *“You are a creative master chef. When given ingredients and a cooking method, you invent a new dish. Provide the dish name and a one-sentence description. Ingredients: {list}. Method: {method}. Dish:”*. We will include a few examples in the prompt (few-shot learning) to anchor the style – e.g., *“Ingredients: tomato, pasta; Method: boil → Dish: Pasta Marinara – A simple hearty dish of boiled pasta in a rich tomato sauce.”* This helps the LLM understand the format.  
- **LLM Model Choice:** Initially, we can use a high-capability model like GPT-4 for development to ensure creative and coherent outputs. However, for deployment we might consider an open model (like Llama 2 via an API or hosted) to control costs. Neal Agarwal noted that Llama 2 required careful prompt tuning and wasn’t as “smart” as GPT-4 ([This browser-based 'endless crafting game' starts you off with fire and water, but it quickly escalates to God, the Big Bang, and 'Yin-Yoda' | PC Gamer](https://www.pcgamer.com/this-browser-based-endless-crafting-game-starts-you-off-with-fire-and-water-but-it-quickly-escalates-to-god-the-big-bang-and-yin-yoda/#:~:text=Though%20Agarwal%20noted%20that%20Llama,later%20versions%20of%20the%20game)), so we may need to iterate on our prompt or use a smaller model with fine-tuning. We expect prompt engineering to be an ongoing task (Agarwal *“had trouble figuring out the right prompt and examples”* at first ([This browser-based 'endless crafting game' starts you off with fire and water, but it quickly escalates to God, the Big Bang, and 'Yin-Yoda' | PC Gamer](https://www.pcgamer.com/this-browser-based-endless-crafting-game-starts-you-off-with-fire-and-water-but-it-quickly-escalates-to-god-the-big-bang-and-yin-yoda/#:~:text=him%20some%20trouble%20when%20it,later%20versions%20of%20the%20game))). Over time, as models improve or if we fine-tune on our game’s context, the results will get even better.  
- **Agent Persona:** Though the LLM’s main task is generating content, we can imbue it with a bit of personality. For example, the agent can have a playful tone, making puns or funny names (Infinite Craft generates witty results like *“Pie-rate”* for pirate+pie ([This browser-based 'endless crafting game' starts you off with fire and water, but it quickly escalates to God, the Big Bang, and 'Yin-Yoda' | PC Gamer](https://www.pcgamer.com/this-browser-based-endless-crafting-game-starts-you-off-with-fire-and-water-but-it-quickly-escalates-to-god-the-big-bang-and-yin-yoda/#:~:text=The%20starting%20elements%20lead%20to,concepts%20or%20pop%20culture%20characters))). We must ensure the tone fits the game’s theme (whimsical fantasy vs. realistic cooking). This persona can be set in the prompt (system message) and will be useful later when expanding to multiple agents (like a merchant AI or customer AI).  

In summary, the LLM agent is the creative core that turns the game from a static recipe list into a living, **improvisational cooking experience**. We will design it to maximize creativity while keeping outputs game-appropriate (we’ll need content filters to avoid truly off-the-mark or unsafe outputs, which we’ll consider in testing).

### Quality and Economic Systems Conceptualization  
To make the gameplay deeper, we need systems for **judging recipe quality** and for an **in-game economy** to trade goods. Early conceptual ideas:

- **Recipe Quality System:** Not all dishes are created equal. Inspired by games like Genshin Impact and Cooking Mama, we plan a quality grading for each dish. In concept, every generated dish will get a quality level (perhaps a numerical score or a tier like *Poor/OK/Good/Excellent*). This could be determined by a hybrid of rule-based logic and AI assistance. For example, we might assign internal “synergy” values for ingredient combinations (some ingredients naturally go well together, some clash). A dish that combines sweet + savory + appropriate cooking method might score high, whereas mixing fish, chocolate, and milk in a soup might score low – even if the LLM gives it a nice name. Additionally, the LLM’s description might be parsed for sentiment (if it uses words like “burnt” or “strange,” we lower the quality). The **three-tier model from Genshin** is a good simple template: a dish can come out *Suspicious (low)*, *Normal*, or *Delicious (high)*, affecting its effectiveness by ±20% ([Food | Genshin Impact Wiki | Fandom](https://genshin-impact.fandom.com/wiki/Food#:~:text=Food%20items%20have%203%20different,regardless%20of%20the%20food%27s%20quality)). We can adapt this to our game (e.g., taste affecting sell price or buff strength). The quality system will add a layer of **challenge** – players might try to find ingredient combos that yield higher-quality dishes, not just any dish. It also ties into the economy: better quality means higher value. The dish could fail by undercooking a meat or overcooking to lead to "Unedible Repulsive Slob" or whatever the AI thinks as we want to ensure that the food created would be safe to consume. This would encounter edge cases. Also, we should heavily train on dishes that ALREADY EXISTS.  
- **Economic System Concept:** The game will feature an in-world economy to make use of the cooked dishes. Players will likely have a shop or market where they can sell their creations and buy new ingredients. We envision using a **dynamic pricing** model rather than static prices. This means prices can fluctuate based on supply and demand or other factors, making the world feel more alive. (For example, selling many of the same dish could saturate the market and drive its price down, encouraging variety.) Dynamic game economies are more engaging – e.g., in *EVE Online* the player-driven market causes prices to fluctuate constantly based on supply/demand ([The Fundamentals Of Game Economy Design: From Basics To Advanced Strategies – Alts.co](https://alts.co/the-fundamentals-of-game-economy-design-from-basics-to-advanced-strategies/#:~:text=Static%20vs,realistic%20and%20engaging%20economic%20environment)). Our game’s economy might not be as complex, but we can simulate basic supply-demand: common dishes yield less profit, rare high-quality recipes fetch premium prices. We’ll also include *currency* as a soft resource that players use to buy ingredients or upgrades (like better cookware that might influence quality). The economic system gives long-term goals: earn money to expand your kitchen, unlock rare ingredients, etc., tying the creative cooking into progression.  
- **Progression and Goals:** With quality and economy in place, we can conceptualize overarching goals: for example, **quests or challenges** like “Cook a 5-star dessert” or **customer requests** (“a villager asks for a hearty stew”). Meeting these goals yields rewards and guides the player’s experimentation. We might include a recipe book (automatically recording LLM-discovered recipes) which players can fill out – creating a *“gotta cook ’em all”* collectible aspect that drives replayability.

At the end of this phase, we have a clear **game concept**: an open-ended cooking sandbox powered by an AI chef, with systems for quality feedback and an evolving economy to ground the experience. Next, we assess technical feasibility and build a prototype to validate these ideas.

## 2. Technical Feasibility & Prototyping

### Tech Stack Recommendation and Rationale  
To implement the game as a **web-based application**, we choose a tech stack that supports an interactive game loop, real-time updates (for inventory, etc.), and integration with LLM APIs:

- **Frontend:** We will use a web front-end capable of rendering a pixel-art style game and handling user input for selecting ingredients and cooking actions. A good option is **HTML5 canvas** with a framework like **Phaser 3** (a popular 2D game framework) or **PixiJS** for low-level rendering. This allows us to draw sprites (ingredients, cooking pot, etc.) in a pixelated style and manage simple animations (boiling effect, etc.). We could also integrate this with **React** for UI components (like menus, inventory screens) since React can manage state for non-canvas elements. The front-end will handle showing the cooking interface, inventory, and store. Pixel-art aesthetic considerations (discussed later) mean we’ll use CSS/Canvas settings that preserve hard edges (no anti-aliasing on pixel images).  
- **Backend:** A server is needed to handle game logic that should not be on the client (especially calls to the LLM API, which require a secret key and have latency). We can use **Node.js** with Express (if we want a simple REST API for the client to request a cooking result or to buy items). Node is suitable especially if we use JavaScript on front-end, sharing some utility code. Alternatively, **Python (Flask/FastAPI)** could be used if we prefer Python for easier handling of LLM integration (since Python has good libraries for calling AI APIs and possibly caching results). Either way, the backend will manage the database and call out to the LLM service.  
- **Database:** We will need to persist game data: discovered recipes, player inventories (if we want accounts or persistent play), and perhaps the global catalog of combinations. A lightweight **SQL database** like SQLite or a cloud DB (PostgreSQL) is sufficient for a prototype. This will store mappings of ingredient combos -> generated dish (for quick lookup after first discovery), and shop inventory/prices. If we eventually allow multiple players (MMO aspect of sharing discoveries), a database is essential to sync their game state and the global economy.  
- **LLM API:** For the AI, during prototyping we’ll use a reliable hosted API (like OpenAI’s GPT-4/GPT-3.5 or AI21, etc.) to ensure quality outputs. OpenAI’s API will provide strong natural language generation for creative recipes. We’ll need to design prompts carefully and possibly use **temperature** settings to control randomness (e.g., a moderately high temperature to encourage creativity, but not so high that outputs are too random or incoherent). We should also plan for cost management – caching results in the DB helps avoid repeat calls. If using OpenAI, we must implement their safety best-practices (the content filter) to catch any inappropriate outputs. In the longer term, we could consider hosting an open-source model (like Llama 2) ourselves to cut costs, as Neal.fun did via Together AI ([How does the game infinite craft work? : r/NoStupidQuestions](https://www.reddit.com/r/NoStupidQuestions/comments/1atymj3/how_does_the_game_infinite_craft_work/#:~:text=LLMs%20are%20quite%20expensive,or%2063%20dollars%20per%20hour)). The backend will abstract the LLM calls so we can swap providers if needed.  

**Rationale:** This stack is chosen for familiarity and scalability – web tech for easy accessibility (no install, just play in browser), and a backend that can handle the LLM heavy lifting. Using a canvas/webGL-based library ensures we can implement a dynamic UI (drag-and-drop ingredients, animated cooking) which pure HTML/CSS might struggle with. The chosen technologies are all widely used and have strong community support, reducing development friction.

### LLM Prompt Engineering Strategies and API Testing  
Before writing full game code, we will prototype the LLM interaction to ensure it meets our needs. Prompt engineering is a critical part of feasibility:

- **Designing Effective Prompts:** As described in the conceptual phase, we start with a carefully structured prompt. We will test and iterate on this prompt using examples of ingredient combinations. For instance, we might manually query the LLM in a notebook with a few combinations to see if it responds with sensible dish ideas. We’ll refine the wording and included examples until the format is consistent. Key strategies include:
  - Using **few-shot examples**: Provide 2–3 example inputs and outputs in the prompt so the model learns the pattern (e.g., *ingredient list + method → “Dish Name – Description”* format).  
  - Setting a **system message** (if using OpenAI) that defines the role (“You are an imaginative chef...”) to guide tone and avoid undesired content (we can instruct it to avoid mention of real trademarks or overly modern jokes if that breaks immersion).  
  - Controlling **randomness**: We’ll likely set `temperature` ~0.7 for creativity. In testing, we might adjust this; if outputs are too wild, lower it, if too bland, raise it.  
  - Enforcing **output format**: We may need to instruct the model to output in a specific format (like “Name – Description – [Quality]”), perhaps by using delimiters or JSON. Early tests will show if this is necessary or if natural language output is enough.  
- **API Testing:** We will conduct a series of tests with the chosen LLM API:
  - *Basic combinations:* feed simple combos (e.g., “apple + meat, simmer”) and verify we get a reasonable dish (like “Stewed Fruit & Meat – A sweet and savory stew that restores health”). We check for coherence and that the model indeed uses both ingredients in the idea.  
  - *Edge-case combos:* try odd pairs (e.g., “rock + tomato, bake”) to see how the model handles bizarre inputs. We expect creative or humorous results (“Stone-Fired Tomato – A dish so hard you could crack a tooth!”). This ensures even invalid food combos yield something entertaining.  
  - *Repetition:* test the same input multiple times (with fixed random seed if possible) to gauge output consistency. Ideally, with temperature moderate, we might get slight variations. For consistency in-game, we will stick to one result per combo (by caching the first result). If the model outputs drastically different answers on subsequent calls, we might enforce deterministic behavior (setting temperature 0 for repeat combos after the first time, or simply always use the cached result).  
  - *Performance:* measure response time of the API call, since this affects user experience. If calls take >2 seconds, we may need a loading indicator in UI or consider ways to optimize (like smaller prompts or local inference if feasible).  
  - *Cost simulation:* estimate how many calls a typical play session could make and the token usage. This is to ensure our approach is financially viable. We know from Infinite Craft discussion that thousands of requests can add up in cost ([How does the game infinite craft work? : r/NoStupidQuestions](https://www.reddit.com/r/NoStupidQuestions/comments/1atymj3/how_does_the_game_infinite_craft_work/#:~:text=LLMs%20are%20quite%20expensive,or%2063%20dollars%20per%20hour)), so our caching and perhaps rate-limiting of new combos are important.  

By the end of this testing, we should have a refined prompt and configuration for the LLM that reliably produces good content. We’ll document the final prompt and include example outputs in our design docs.

### Minimal Prototype Implementation (LLM-driven Cooking Results)  
With the tech stack and LLM behavior validated, we’ll build a **minimal viable prototype** focusing on the core mechanic: combining ingredients to get an AI-generated dish. The prototype will include: 

- **Ingredient Selection UI:** A simple interface (even text-based or minimal graphics) where a player can choose 2–3 ingredients from a list and a cooking method. For prototyping, we can hard-code a small set of ingredients (e.g., flour, meat, apple, mushroom, etc.) and 2 methods (boil, fry). The player might select via dropdowns or drag icons into a "pot".  
- **“Cook” Action:** A button that, when clicked, sends the selected combo to the backend. The backend calls the LLM and receives a dish name/description (and possibly quality). During this call, the UI can show a simple loading message or animation (e.g., “Cooking...”).  
- **Result Display:** Once the response returns, display the new dish to the player. For the prototype, a text output is fine: e.g., *“You created **Mushroom Pie** – A hearty pie filled with rich mushroom gravy. (Quality: Good)”*. This confirms the whole pipeline works (UI -> backend -> LLM -> UI). We’ll check that the result matches our expectations from earlier prompt testing.  
- **Inventory Mechanism:** Implement a basic inventory to store results. For now, this could just be a list on screen that appends each new dish (name, description, maybe an icon placeholder). This ensures we can handle multiple results over time and gives the player a sense of collection.  
- **No Persisted Save:** In the initial prototype, we might skip database persistence – the focus is on real-time functionality. If the player refreshes, it’s okay to lose data at this stage. We can simulate persistence by keeping data in memory on the backend for the session.  

We will iteratively test this prototype ourselves. Does clicking through feel satisfying? Are the outputs interesting and varied? For example, if one round we cook “meat+apple” and get a dish, what if we swap order or add a third ingredient? The prototype will help reveal any issues like prompt too generic (maybe all dishes come out as “mix of X and Y” type names – we might then tweak the prompt to encourage more varied naming).

This minimal prototype achieves **end-to-end functionality** of the core loop: choose inputs -> LLM generates outcome -> outcome shown. It will be a foundation to build upon. If any part of this fails (e.g., LLM consistently gives poor results), we would revisit the design or model choice now.

### Prototype Store and Inventory Mechanics  
In parallel or after the cooking prototype, we’ll prototype simplified **inventory and store systems**, as these support the core loop:

- **Inventory System:** We already started an inventory list in the prototype. We’ll flesh this out into an interface where the player can see all owned ingredients and all created dishes. This could be as simple as two lists on the screen with item names and quantities. We will implement functions to **add/remove items**. For example, after cooking, it deducts 1 of each used ingredient from the ingredient inventory and adds 1 new dish item to the dish inventory. This ensures resource management is working (so cooking consumes ingredients). We’ll also add a way to *gain* ingredients for testing – perhaps a debug button “Add 5 apples” or automatic starting stocks, so we can actually perform cooking repeatedly.  
- **Basic Store Interface:** A simple store can be a panel where a few **ingredients are for sale** with prices, and the player can buy them using currency, as well as **sell dishes** for money. In the prototype, we can hard-code 3 ingredients (e.g., flour $5, meat $10, mushroom $7) available to buy, and set selling prices for dishes equal to some base (maybe $8 each for any dish, just to test transaction flow). The player’s currency can be tracked as a number. Buying an ingredient reduces currency and increases that ingredient in inventory; selling a dish does the opposite. This will test the loop of **economy**: cook dishes -> sell for profit -> buy more ingredients -> cook more. Even without dynamic pricing yet, this is the seed of the economic gameplay.  
- **Integration with Core Loop:** We make sure the cooking prototype ties into these systems: if the player lacks required ingredients, the Cook button should be disabled (or show a message). This involves checking inventory counts before allowing a combination. Also, after getting a dish, it should appear in inventory so it can be sold.  
- **Data Structures:** At this stage, in-memory JavaScript objects or simple JSON storage is fine (e.g., `playerInventory = {apple: 2, meat: 1, ...}` and `dishes = [{name: "Mushroom Pie", quality: "Good"}]`). We’ll ensure the code is structured so later we can replace these with database calls.  

This prototype store will be rudimentary, but it lets us verify that the **core loop is fun with all components**: you start with some money, buy ingredients, cook something cool with the AI, then can sell it and feel rewarded to buy even more ingredients. If the loop is satisfying even in this simple form, we have a strong signal to proceed. We’ll gather some initial feedback (maybe have a colleague try the prototype) to see if the concept “clicks” for players.

## 3. System Development & Refinement

With a working prototype, we move to building out the full game systems, improving robustness and depth. This phase focuses on memory/consistency for the AI, fleshing out quality and pricing systems, expanding the store features, and polishing the UI to match the pixel-art vision.

### LLM Memory and Consistency Strategies  
As we scale up, maintaining consistency in the AI’s behavior and the game world is crucial:

- **Recipe Memory (Database):** We will implement a **persistent recipe database** that records each unique ingredient+method combination the first time it’s cooked, along with the LLM-generated result. This serves multiple purposes: it ensures that if the player (or any player, in a multi-player scenario) tries the same combination again, they get the *same* dish name/description as originally (consistency in the game lore), and it saves us from calling the LLM API again for known recipes (saving cost and avoiding slight variations). As noted earlier, Infinite Craft does this – it *“stores combinations so that it can be looked up without asking the LLM”* after the first time ([How does the game infinite craft work? : r/NoStupidQuestions](https://www.reddit.com/r/NoStupidQuestions/comments/1atymj3/how_does_the_game_infinite_craft_work/#:~:text=%3E%20,what%20the%20result%20should%20be)) ([How does the game infinite craft work? : r/NoStupidQuestions](https://www.reddit.com/r/NoStupidQuestions/comments/1atymj3/how_does_the_game_infinite_craft_work/#:~:text=Presumably%2C%20combinations%20that%20have%20already,up%20without%20asking%20the%20LLM)). We’ll design the DB schema with a table `Recipes` having columns: `ingredients (key)`, `method`, `dish_name`, `description`, `quality`. When a cook action comes in, the backend will first query this table; if found, return the stored result immediately, if not, call the LLM, then store the new result. We’ll also mark new discoveries in the UI (e.g., “New Recipe Discovered!”) to give the player a sense of accomplishment.  
- **Session Memory (Contextual Consistency):** While each recipe generation is mostly independent, we might introduce some contextual interactions with the LLM that require memory. For instance, if we later have a *conversation* with a customer agent (“I want something spicy”), the LLM generating the recipe might need to remember that request. For such cases, we will maintain a **game state context** that can be injected into prompts. An example game state might include current customer preferences, recent actions, or the player’s reputation. We can feed this into the LLM prompt to influence output. This is akin to what text adventure AI games do: *“Game state enhances memory... inputting the state information into the LLM”* ensures continuity ([[Part 1] Crafting a Text Adventure Game with LLMs in Just 6 Hours! | by Dain Kim | Medium](https://medium.com/@ddanakim0304/part-1-crafting-a-text-adventure-game-with-llms-in-just-6-hours-bb415ebbb67a#:~:text=Game%20state%20enhances%20memory%2C%20provides,items%20not%20in%20the%20inventory)). In our context, before calling the LLM for a recipe, we might augment the prompt with relevant context, like `If customer X requested a spicy dish, ensure the dish is spicy`. This helps maintain narrative consistency if needed.  
- **Determinism and Reproducibility:** We will configure the LLM API for more deterministic outputs when appropriate. For known recipes, as mentioned, we might set temperature=0 (fully deterministic) to avoid random fluctuations. If using OpenAI, we could also use their *function calling* or formatting to get structured output that we parse reliably (ensuring we always extract the name and description correctly). Additionally, if we run our own model, we can use a fixed random seed for generation of known combos to guarantee the same result. Consistency is important so players can rely on their knowledge – e.g., if they discovered “Spicy Meat Stew” yesterday, cooking those ingredients again tomorrow should yield that same stew (unless they intentionally try a different method to create a variant).  
- **LLM Token Limits & Scaling:** As more content is discovered, prompts that include examples or lists might grow. We must manage the prompt size to avoid hitting token limits. We’ll likely keep prompts concise and not include the entire history of recipes (that’s what the database is for, not the AI’s memory). If needed, we can use embedding-based search to provide the LLM with just a few relevant similar recipes to maintain thematic consistency (for example, if combining two very novel ingredients, we might feed it 1-2 examples of known combos as inspiration). But this is an advanced tactic; initially we assume each request is standalone with a fixed prompt template.  
- **Multiple Agents Memory:** In the next phase we introduce multiple AI agents (chef, customers, etc.). We will give each agent its own context memory. For instance, a customer agent might remember the last dish the player served them (so they can comment on it later). We can implement this by storing a small state for each NPC (e.g., a dict with preferences, last interaction) and include that in their prompt when they speak. Documentation of these states will be important to debug agent behaviors.  

By implementing these memory strategies, we ensure our LLM behaves in a **predictable and coherent** way within the game’s universe, which is key for player trust and enjoyment. The game will feel more solid when the AI isn’t forgetting things it should logically “know” (like known recipes or a customer’s tastes).

### Hybrid Quality System Implementation  
We now build the **quality evaluation system** for dishes, combining deterministic rules with AI nuance:

- **Rule-Based Scoring:** Each ingredient will be given certain properties and point values. For example, in a fantasy setting, a “fresh herb” might add +2 aroma points, “monster flesh” might add +5 protein but -3 palatability. We will create a formula that sums up contributions of ingredients and perhaps the cooking method. (This is inspired by how BOTW has hidden ingredient potency values that sum up to determine effect strength ([Zelda: Breath of the Wild cooking explained - ingredients list, bonus effects, and how to cook with the cooking pot | Eurogamer.net](https://www.eurogamer.net/zelda-breath-of-the-wild-cooking-ingredients-list-bonus-effects-how-to-cook-with-the-cooking-pot-4857#:~:text=Cooking%20in%20Breath%20of%20the,the%20most%20out%20of%20it)) ([Zelda: Breath of the Wild cooking explained - ingredients list, bonus effects, and how to cook with the cooking pot | Eurogamer.net](https://www.eurogamer.net/zelda-breath-of-the-wild-cooking-ingredients-list-bonus-effects-how-to-cook-with-the-cooking-pot-4857#:~:text=deeper%20mechanics%20of%20cooking%2C%20like,at%20the%20campfire%27s%20cooking%20pot)).) The result of this calculation could be a base score. We’ll also incorporate combination bonuses/penalties: e.g., if sugar + flour + fruit are all present, that’s a known good combo (a dessert) so +10%. If an ingredient combination is inherently odd (fish + chocolate), we apply a penalty. These rules can be defined in a config file for easy tweaking.  
- **LLM Description Analysis:** To add the AI’s “opinion,” we parse the LLM’s output text for certain keywords or tone. If the description uses very positive language (“delicious”, “savory aroma wafts”), we might boost the quality a bit. If it uses negatives (“burnt”, “strange texture”), we reduce the score. This effectively lets the LLM indirectly influence quality based on how it chose to describe the dish. We must be careful, though, as the LLM might not always indicate quality explicitly (it tends to be positive unless instructed to sometimes produce “bad” dishes). We might even explicitly ask the LLM to give a quality rating, but that could lead to inconsistency. A safer approach: maintain our rule-based score as primary, and use the AI cues as minor modifiers.  
- **Quality Tiers:** Based on the final score, assign a tier or star rating. For example:
  - 0–3 points = *Poor* (or 1-star, depicted maybe as a gray star or a crummy looking dish sprite).  
  - 4–6 points = *Decent* (2-star).  
  - 7–9 = *Good* (3-star).  
  - 10+ = *Excellent* (4-star).  
  - (We could have a 5-star “Legendary” tier for extremely high scores or special secret combos.)  
  Genshin’s 3-tier (Suspicious/Normal/Delicious) model could map similarly (Suspicious = Poor, Normal = Good, Delicious = Excellent) ([Food | Genshin Impact Wiki | Fandom](https://genshin-impact.fandom.com/wiki/Food#:~:text=Food%20items%20have%203%20different,regardless%20of%20the%20food%27s%20quality)). We’ll likely display quality visually (stars or an adjective) alongside the dish.  
- **Impact of Quality:** We implement the effects of quality on gameplay. High-quality dishes sell for more and could provide better effects if consumed. Low-quality ones might sell for a pittance or even have negative effects (in BOTW, the dubious food only restores a little health). This creates a gameplay incentive to strive for better recipes. The quality system should be **transparent enough** that players learn how to improve (we can give hints like “Adding a spice might improve the aroma of this dish”). It also adds an element of **skill/knowledge**: though the LLM is doing creative work, the player’s understanding of ingredients and game logic can influence outcomes.  
- **Dynamic Adjustments:** During playtesting, we’ll adjust the scoring rules to ensure balance. If every random combo ends up “Good” quality, we might need to tighten criteria to make quality feel earned. Conversely, if it’s too hard to get anything above mediocre, players might feel frustrated. We’ll use the data of crafted dishes in testing to calibrate (this is where having logs of recipes and their quality helps us tune the algorithm).  

Implementing this hybrid system gives us the best of both worlds: **consistency and fairness** (from the rule-based component) and **flavorful variability** (from the AI’s touch). It grounds the AI’s creativity in the game’s mechanics.

### Dynamic Pricing Implementation  
With quality in place, we turn to the economy. We replace the prototype’s fixed prices with a more dynamic system:

- **Base Prices:** Assign each ingredient a base price (as in prototype) and perhaps each dish a base price as well (e.g., sum of ingredient costs times a factor for the cooking effort). But instead of static, this will be just the starting point.  
- **Quality Influence:** A straightforward rule: higher quality dishes fetch higher prices. For example, each quality tier could be +50% price. If a Normal dish base price is $10, a Delicious/Excellent one could be $15, and a Poor one $5. This makes quality immediately meaningful in the market.  
- **Supply and Demand Simulation:** We introduce variables for market demand of each item (ingredients and dishes). Each time the player sells a dish, the supply for that dish type increases in the market, which could lower its future price. Conversely, if the player hasn’t sold a certain dish in a long time, demand might build up, raising its price. We can model this simply: maintain a counter of how many of each item have been sold recently and adjust price by a small percentage per unit. For example, for every 5 identical dishes sold in a in-game week, their price drops 10%. Over time (each day), demand can recover (prices creep back up) if not continually sold. This prevents one overpowered recipe from breaking the economy – if the player mass-produces it, the profits diminish, nudging them to diversify.  
- **Random Market Events:** To make the economy lively, we can add random or scripted events. E.g., a message: “A festival is in town – people crave sweets!” causing all dessert-type dishes to double in price for that day. Or “Bad harvest of mushrooms – mushroom prices skyrocket.” These can be random or tied to an in-game calendar. It gives the player short-term goals (take advantage of a boom, or pivot when a bust happens). Implementation-wise, this means occasionally tweaking demand multipliers for categories of items.  
- **Merchant/Economic Agent:** We might implement the economy logic within an **economic AI agent** for flexibility. For instance, instead of purely formulaic, we could have an LLM agent (with a system prompt like “You manage the market. Adjust prices based on trends.”) generate shopkeeper dialogue and set prices. However, this might over-complicate things and could be less predictable. A safer route is to implement the dynamic pricing with code (which is more transparent and testable) and use an LLM agent only to *narrate* the economy (e.g., a merchant character explaining why prices changed, to immerse the player). This hybrid approach gives us controlled mechanics with AI flavor texts.  
- **Transparency to Player:** We will communicate the dynamic economy to the player through UI cues or NPC dialogue. For example, show arrows next to item prices (green up arrow if price rose today, red down if fell). Or have the store NPC say “Mushrooms are plentiful lately, they’ve become cheaper.” This helps players adapt and strategize. A purely hidden dynamic system could confuse players, so some feedback is important ([The Fundamentals Of Game Economy Design: From Basics To Advanced Strategies – Alts.co](https://alts.co/the-fundamentals-of-game-economy-design-from-basics-to-advanced-strategies/#:~:text=availability%20remain%20constant%2C%20as%20seen,realistic%20and%20engaging%20economic%20environment)) (static economies are easier to plan for ([The Fundamentals Of Game Economy Design: From Basics To Advanced Strategies – Alts.co](https://alts.co/the-fundamentals-of-game-economy-design-from-basics-to-advanced-strategies/#:~:text=Static%20vs,realistic%20and%20engaging%20economic%20environment)), but dynamic ones are more engaging if understood).  

After implementing, we will simulate some scenarios (perhaps write tests or use debug commands to mass-sell items) to see if prices behave reasonably. We’ll adjust parameters (drop rates, caps on price changes) to ensure the economy remains fun and doesn’t spiral out of control.

### Store Dynamics: Random and Player-Created Content  
We enhance the in-game store (or marketplace) beyond the prototype, making its inventory interesting:

- **Random Ingredient Stock:** Each in-game day, the store’s available ingredients (and possibly other items like spices, cookware upgrades, etc.) should refresh. We’ll have a pool of all ingredient types, and randomly select a subset to be “in stock” daily, with limited quantities. This mimics games like Stardew Valley or Animal Crossing where shops have rotating stock. It encourages players to adapt: e.g., “The market has rare truffles today, grab them while you can!” Implementation: we can use a simple random choice with weights (common items appear often, rare ones seldom). Over time, this gives players access to all ingredients but in a staggered way, gating rapid progression.  
- **Introduction of New Ingredients:** As the player progresses (maybe after completing certain quests or reaching certain days), we’ll add new ingredients to the pool, perhaps via a narrative event (“A new merchant from afar brings exotic spices!”). This ensures a sense of progression and continually expands the space of possible recipes (keeping the LLM busy with new combos).  
- **Player-Created Items in Store:** One exciting feature is having the player’s own cooked dishes show up for sale or requested by others. For example, if the player cooks a unique dish that becomes popular, the store or NPC vendors might start selling that dish (essentially the player has introduced a new product to the world). We can simulate this by adding a top-quality dish of the player to the store inventory (the game “auto-produces” some as if NPCs learned the recipe). It’s largely a flavor feature, but it makes the world feel reactive to the player’s creativity. Alternatively, we could allow the player to formally **submit a recipe** to a town restaurant, which then appears daily on their menu for income share. These mechanics tie the creative aspect into the game world’s fabric.  
- **Customer Orders / Requests:** Though not exactly store inventory, it’s related to dynamic content: we can have NPC customers periodically request specific dishes (“I’ll pay extra for a **Spicy Meat Stew** if you can make one”). These requests could be generated based on the dishes the player *can* make (or even slightly beyond to push them). This introduces a directed goal amid sandbox play. The requests can be handled by our planned customer AI agent, but the system to generate which item and reward can be rule-based. For now, we plan that fulfilling orders yields bonus payment or rare ingredients. This adds a quest-like element and can highlight the player’s invented recipes (“Word got around about your Mushroom Pie, now someone wants 3 of them!”).  

All these dynamics – random stocks, evolving inventory, integration of player creations – ensure the game world feels **alive and responsive**. The player will continually encounter new opportunities and see their impact, rather than a static shop list every day.

### UX/UI Guidelines for Pixel-Art Aesthetic  
As we move from prototype to a polished product, we commit to a **pixel-art visual style**. Here are our guidelines for the UI and graphics to achieve a cohesive look:

- **Resolution and Scaling:** We will pick a base resolution (for example, designing at 320×180 or 640×360 which scales cleanly to 1080p by integer factors). All pixel art assets (ingredient icons, character sprites, etc.) will be drawn to that base scale. When rendering, we use nearest-neighbor scaling to preserve hard pixel edges (no blur). It’s important to **mind the target resolution for the game itself, regardless of display**, to keep pixels consistent ([What are the best practices when designing pixel art for mobile ...](https://www.quora.com/What-are-the-best-practices-when-designing-pixel-art-for-mobile-games#:~:text=,where%20it%20will%20be%20displayed)). For instance, each in-game tile (like an ingredient slot) might be 16×16 pixels at base, scaled up 3x on a 1080p screen to appear as crisp 48×48 blocks. We will avoid mixing multiple resolutions of art; everything should follow the same pixel grid size to maintain a unified look.  
- **Art Style:** The art will likely be reminiscent of 16-bit era games – bright, cartoony representations of food items and tools. Ingredients should be recognizable in tiny form (this means using iconic colors and shapes – e.g., a red pixelated apple with a green stem, a brown drumstick for meat). We’ll use a limited color palette for coherence and possibly outline important sprites with a darker color to help them stand out on backgrounds.  
- **Interface Layout:** The UI should be simple and **intuitive**. Likely, the main screen will have a cooking area (with a pixel art stove/pot), an inventory sidebar, and a way to toggle to the shop screen. We will use pixelated font for numbers and text to match the style (many retro-like fonts are available). However, we must ensure readability, so we won’t go too tiny with text – possibly use a higher-res font or a bold pixel font for dialogue and item descriptions. Short paragraphs of text (like item descriptions) can be shown in a panel with a semi-transparent background behind to ensure contrast.  
- **Feedback and Animations:** Pixel art doesn’t mean static. We can add charm with small animations: e.g., a puff of pixel smoke and a *“ding!”* when cooking completes, a coin icon moving to purse when selling, etc. Animations should be kept simple (a few frames) to maintain the retro feel. We will also use sound (8-bit style chimes, clicks) to reinforce feedback.  
- **UX Considerations:** Keep interactions minimal and clear. Drag-and-drop vs clicking: dragging ingredients into a pot is tactile and fun, so we should support it (ensuring the drag ghost is a pixelated icon). Also allow clicking an ingredient then clicking “Add to Pot” for accessibility. Highlight selectable items with a pixel highlight border. When an item is out of stock or the player lacks funds, show a grayed-out icon. Use tooltips or small popup labels to identify items if needed (a pixel art icon might not always be obvious, so hovering could show “Mushroom x3”).  
- **Responsive Design:** While it’s a web game, we should ensure it’s playable on different sized screens. The pixel-art can scale, but we might need to rearrange UI for very small windows. Possibly, we allow fullscreen on desktop for full immersion. Also consider mobile browsers – touch controls should work (Phaser can handle touch events for drag-drop). Buttons should be large enough in terms of pixel units to be easily tapped.  

By adhering to these UI/UX guidelines, we ensure the game is not only attractive in a retro-inspired way but also **user-friendly**. The nostalgic pixel look will appeal to players’ sense of charm, but modern UX considerations will prevent frustration that sometimes came with old games. We will test the interface thoroughly to fine-tune its layout and clarity, ensuring that even someone new can figure out how to cook their first dish without confusion.

## 4. Agentic AI Enhancements & Documentation

In this final phase, we leverage the power of multiple AI agents to enrich gameplay, and we solidify all documentation and testing for a polished product. This will showcase advanced AI integration and thorough system design – great for the resume and, more importantly, great for the game’s depth.

### Designing Multiple AI Agents (Creative, Economic, Customer)  
Beyond the core chef LLM, we introduce additional agents to simulate a living world:

- **Creative Chef Agent:** This is essentially the LLM we've been using for recipe generation. We solidify its role: it’s the **creative engine** behind every new dish. At this point, we might personify it as an in-game character (perhaps an ancestral cooking spirit or a magical cookbook that talks). However, to the player, this agent mainly works behind the scenes (via the cooking pot interface). We maintain its prompt tuning as discussed, ensuring it remains focused on recipe output.  
- **Economic/Market Agent:** We create an AI agent to embody the *storekeeper* or *market* that we designed. While prices are governed by algorithms, this agent can provide a narrative layer. For example, we prompt the agent with the current price changes and ask it to generate a bit of dialogue or a news blurb each day: *“Market Merchant: 'Grain prices have doubled after the poor harvest. Stock up while you can!'”*. This agent could also advise the player: *“Perhaps you should try selling something other than mushroom pie, everyone’s doing that these days.”* The benefit of using an LLM here is more dynamic and context-aware commentary that makes the economy feel humanized. Technically, we feed the agent data like top 3 price changes or any events, and have it output a few sentences of flavor text. It doesn’t directly control prices (to maintain balance), but it reacts to them.  
- **Customer/Quest Agents:** These are perhaps the most engaging use of additional LLMs. We can create several **customer NPCs**, each with a persona (e.g., a brave knight who wants strength meals, an elderly woman craving a nostalgic soup, a food critic seeking the unusual). When a customer agent is active, it will ask the player for a dish or react to what the player gives. We’ll give each agent a memory of past interactions and preferences. For instance, the knight remembers the player served him a spicy stew last time and enjoyed it, so next time he might say, “That stew last time was great! Got anything even spicier?” This context is stored in a little profile and included in the prompt when generating the agent’s dialogue. The customers essentially function like quest-givers or repeat clients, adding a personal touch to the cooking goals.  
- **Interactions Between Agents:** While each agent largely addresses the player, we might script some interactions among them for world-building. For example, the market agent could gossip about the critic: “The food critic is in town; he might pay handsomely for something novel.” This can all be written in advance or procedurally generated with the LLM referencing the agents’ states. However, full unscripted LLM-to-LLM conversation can be unpredictable and is probably unnecessary; our focus is using agents to enrich player interaction.  

By giving these agents distinct **roles and prompts**, we essentially create a multi-agent system where *“AI-powered agents interact with each other and their environment”*, making the game world feel more organic ([SmythOS - Multi-agent Systems in Gaming: Enhancing Player Experience and AI Interaction](https://smythos.com/ai-agents/multi-agent-systems/multi-agent-systems-in-gaming/#:~:text=Multi,create%20amazing%20experiences%20for%20players)). Each agent is like a “mini-brain” for a specific domain (creativity, economy, customer dialogue), and together they elevate the experience beyond just cooking. This design is not only fun but also showcases advanced AI orchestration skills.

### Dynamic Prompts and Contextual Generation  
To make these agents effective, we implement **dynamic prompting** techniques:

- **Contextual Data Injection:** As mentioned, we feed each agent relevant context each time it generates output. For the **chef agent**, context might be limited (just the ingredients/method, and possibly player’s cooking skill level if that’s a factor). For the **market agent**, context includes current prices/trends. For a **customer agent**, context includes their previous dialogues, the dish they last bought, their known preferences (maybe they have a profile saying “doesn’t like spicy”). This context can be stored in our game state and passed into the prompt. We might use prompt templates like:  
  *System:* “You are a friendly market merchant. You know the following market info: {info}. Mention one or two big changes in prices today.”  
  *System:* “You are a customer named Alice. You love sweet foods. Last time, the player served you {last_dish} and you {opinion}. Now you are requesting a new dish.”  
  Using these templates ensures the LLM has guidance and memory to produce contextually appropriate output.  
- **Adaptive Dialogue:** We will use the LLM’s generation to adapt to player actions. For example, if the player fails to deliver a requested dish, the customer agent’s next response may express disappointment. If the player consistently sells cheap food, the market agent might comment on the glut of cheap food. This isn’t strictly required by mechanics, but it adds *emergent narrative*. It shows off the AI’s ability to produce situational responses, making the game feel less scripted.  
- **Fail-safes in Generation:** We’ll include instructions in prompts to avoid certain pitfalls. For instance, instruct customer agents not to reveal the exact recipe needed (to still let the player experiment). Or instruct the market agent not to lie about actual prices (since the underlying system sets those). Essentially, the AI should embellish but not contradict game state. Testing will be needed to ensure they stay in bounds.  
- **Multi-turn Interactions:** If we allow the player to converse with an agent (say a dialogue choice system), we’ll then be engaging in multi-turn prompts. We can manage this by maintaining the conversation history (like a typical chat with ChatGPT) truncated to recent turns to fit in context window. This is an advanced feature; if time is short, we might keep interactions one-shot. However, even one-shot interactions per day can be rich if context is loaded well.  

By fine-tuning these dynamic prompts, we exploit the LLMs to their fullest, creating the feel of a world that **reacts intelligently** to the player. It’s important to note that we will keep generation times and frequency reasonable (perhaps limit how often a customer interaction can happen, to not overload with API calls). With well-structured prompts and context, the AI agents can output in a **consistent style** that matches the game’s narrative voice.

### Comprehensive Documentation  
Throughout development, we will maintain thorough documentation, which not only helps keep the project on track but also is excellent to show in a resume or portfolio:

- **System Architecture Documentation:** We will create diagrams and descriptions of the overall architecture: how the client, server, database, and LLM API interact. For example, a flowchart of “Player action -> Server -> LLM -> Server -> Client update” for cooking a dish. We’ll document each major component (front-end UI, game logic, LLM service, database schema). This could be presented as a short technical design document. It demonstrates our planning of complex systems.  
- **Code Documentation:** As we implement, we’ll comment code generously, especially around the integration points with the LLM and any intricate algorithms (like the pricing formula or quality scoring). Future developers (or recruiters reviewing code samples) should be able to understand our logic easily. If this project is to be showcased, having clean, well-documented code is a big plus.  
- **Prompt and Agent Behavior Logs:** We will keep a **log of prompts and sample responses** for each agent during development. This serves two purposes: debugging and documentation. We can include in our documentation some example conversations with the customer agent, or a list of example recipe generations, to illustrate how the AI behaves. This is compelling in a resume/project write-up, as it shows the AI’s output quality and the designer’s prompt mastery. We might even maintain a “prompt book” – each agent’s prompt template and rationale explained in writing.  
- **Gameplay Design Doc:** Apart from technical docs, we’ll write a manual or design document explaining the game rules (how quality is determined, how economy works in detail). This consolidates all the decisions in one place. It’s useful for testing (testers can refer to it to verify things) and for showing the depth of design thinking.  
- **Task and Iteration Logs:** We should keep track of the playtesting feedback and how we addressed it (perhaps as part of a dev diary). This shows an iterative approach to improvement. For example, “Playtest 1 feedback: dishes felt too random – Solution: implemented quality system and added hints. Playtest 2: economy too punishing – Solution: reduced price drop rate, etc.”. This kind of log demonstrates responsiveness to feedback.  

All this documentation will be packaged perhaps in a GitHub repository wiki or a Notion workspace for the project. Not only does it ensure maintainability and clarity, it **showcases our system design and AI integration skills** comprehensively, which is a key goal (for both the development process and the resume impact).

### Playtesting Strategies and Iterative Improvement  
Finally, we will rigorously **playtest and refine** the game. Playtesting is critical to polish gameplay and validate that the AI agents are enhancing, not detracting from, the fun:

- **Internal Testing:** The development team (and friends/family) will play the game frequently during development. We’ll do session-based testing: e.g., play for 30 minutes focusing on early-game balance (are ingredients affordable? is the first recipe discovery satisfying?). Then a longer session to see mid-game (does dynamic pricing make it harder or easier as time goes on? do agent dialogues become repetitive?). During these tests, we’ll log any odd AI outputs or balance issues. Because AI can be unpredictable, we pay special attention to any output that is inappropriate or breaks immersion, and adjust prompts or add filters accordingly.  
- **Closed Beta Testing:** Once the game is feature-complete, we can bring in external testers (e.g., a small community of enthusiasts or other developers). We provide them the game and maybe a brief survey. We want feedback on general enjoyment, clarity of what to do, and thoughts on the AI-generated content. Specific things to ask: *“Do the dish results make sense and add to the game? Were you ever confused by an outcome or agent dialogue? How is the difficulty of making money? What would you like to see more of?”*. This real-user feedback is gold. We expect to iterate based on it – for example, if players ignore the store and just cook, maybe we need to integrate the economy more tightly or tutorialize it.  
- **Iterative Tuning:** After each testing round, we apply improvements. This could mean adjusting variables (e.g., price formulas, ingredient drop rates), clarifying UI (maybe some players didn’t realize they could scroll the ingredient list, so we add an indicator), or refining AI prompts (if many players felt the customer requests were too vague, we could make the customer agent give clearer hints like “I’d love something with fish in it”). The game design mantra is “*design, test, iterate*” – great games come from multiple refinement loops. *“The more you iterate on a game, the better it becomes”* and playtesting offers *“valuable insights into the game’s mechanics... and overall enjoyment”*, helping us identify what to improve ([Effective Game Playtesting Techniques for Better Results](https://updates.kickstarter.com/effective-game-playtesting-techniques-for-better-results/#:~:text=Playtesting%20is%20a%20crucial%20phase,By%20investing%20time%20in%20thorough)) ([Effective Game Playtesting Techniques for Better Results](https://updates.kickstarter.com/effective-game-playtesting-techniques-for-better-results/#:~:text=In%20addition%20to%20identifying%20bugs%2C,playtesting%20helps%20creators%20refine%20their)).  
- **Balancing with AI in the Loop:** Balancing a game with an AI element is unique because content is not 100% fixed. We will particularly test extreme cases: Can a player abuse the AI to get something unintended (like a dish that sells for an exorbitant price because the AI gave it a certain description)? If such cases are found, we address them (cap prices, or adjust how we derive price from description to avoid exploits). We also ensure that the AI doesn’t accidentally trivialize the game by giving too strong hints (e.g., the AI shouldn’t outright tell the player “combine X and Y for a great result” unless it’s a designed hint via an NPC). These considerations are part of polishing the integration of AI into a fair game experience.  
- **Final Polish and Resume Showcase:** As we conclude iteration, we’ll gather the final documentation, screenshots, perhaps a gameplay video, and samples of AI outputs to compile into a portfolio piece. We will emphasize how the **agentic AI** made the game dynamic: the creative agent allowing “pretty much endless” recipe possibilities, the economic agent creating a living market, and the customer agents generating personalized quests – these are features that set the project apart and demonstrate cutting-edge skills.

After sufficient playtesting and improvements, we’ll arrive at a version of the game that is both **fun and stable**. At this point, we will have achieved an end-to-end development of a complex system: a web-based cooking game infused with LLM-driven creativity and multiple AI agents. Not only will this be an enjoyable game for players, but the development process and outcome will strongly highlight our **AI integration, system design, and iterative development** capabilities, which can be proudly presented in any professional context.

